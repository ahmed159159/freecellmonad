<!DOCTYPE html>
<html lang="ar">
<head>
  <meta charset="utf-8" />
  <title>FreeCell</title>
  <style>
    body { 
      margin:0; 
      font-family:Arial; 
      background: url('background.jpg') no-repeat center center fixed;
      background-size: cover;
      overflow-x:hidden;
    }
    h1 { text-align:center; margin:10px; color:white; }
    #controls { text-align:center; margin:10px; }
    button { margin:5px; padding:8px 15px; border:none; border-radius:5px; background:#1b4332; color:white; cursor:pointer; }
    #game { display:flex; flex-direction:column; align-items:center; }
    #top-row { display:flex; justify-content:space-between; width:900px; margin:10px; }
    #freecells, #foundations { display:flex; gap:8px; }
    #tableau { display:flex; gap:8px; width:100vw; justify-content:center; }
    .pile { 
      width:80px; 
      min-height:120px; 
      border:1px dashed rgba(255,255,255,0.4); 
      border-radius:8px; 
      margin:5px; 
      position:relative; 
      background:rgba(0,0,0,0.1);
    }
    .card { 
      width:80px; 
      height:120px; 
      border-radius:8px; 
      position:absolute; 
      cursor:grab; 
      user-select:none; 
    }
    .card img { 
      width:100%; 
      height:100%; 
      display:block; 
      border-radius:6px; 
      pointer-events:none;
    }
    .hint-glow {
      box-shadow: 0 0 15px 5px yellow;
      z-index: 10;
    }
  </style>
</head>
<body>
  <h1>FreeCell</h1>
  <div id="controls">
    <button onclick="restartGame()">Restart</button>
    <button onclick="undoMove()">Undo</button>
    <button onclick="showHint()">Hint</button>
  </div>

  <div id="game">
    <div id="top-row">
      <div id="freecells"></div>
      <div id="foundations"></div>
    </div>
    <div id="tableau"></div>
  </div>

<script>
const ranks = ["A","2","3","4","5","6","7","8","9","10","J","Q","K"];
const suits = ["S","H","D","C"]; 

let gameState = {
  tableau:[[],[],[],[],[],[],[],[]],
  freecells:[null,null,null,null],
  foundations:[[],[],[],[]],
  history:[]
};

function cardId(c){ return c.rank + c.suit; }
function cardColor(s){ return (s==="H"||s==="D") ? "red" : "black"; }

function createCardImg(card, idx=0){
  const imgWrap = document.createElement('div');
  imgWrap.className = 'card';
  imgWrap.dataset.id = cardId(card);
  imgWrap.style.top = (idx * 25) + "px";
  imgWrap.draggable = true;

  const img = document.createElement('img');
  img.src = `Cards/${card.rank}${card.suit}.jpg`;
  img.alt = card.rank + card.suit;
  imgWrap.appendChild(img);

  imgWrap.addEventListener('dragstart', dragStart);
  imgWrap.addEventListener('dragend', dragEnd);

  return imgWrap;
}

function maxMovableCards(targetCol = -1){
  const freeCount = gameState.freecells.filter(x => x === null).length;
  const emptyCols = gameState.tableau.filter((p, idx) => p.length === 0 && idx !== targetCol).length;
  return (freeCount + 1) * Math.pow(2, emptyCols);
}

function initDeck(){
  let d = [];
  for (let r of ranks) for (let s of suits) d.push({rank:r, suit:s});
  for (let i=d.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [d[i], d[j]] = [d[j], d[i]];
  }
  return d;
}

function restartGame(){
  const deck = initDeck();
  gameState.tableau = [[],[],[],[],[],[],[],[]];
  for (let i=0;i<deck.length;i++) gameState.tableau[i % 8].push(deck[i]);
  gameState.freecells = [null,null,null,null];
  gameState.foundations = [[],[],[],[]];
  gameState.history = [];
  render();
}

function saveState(){
  gameState.history.push(JSON.parse(JSON.stringify(gameState)));
}
function undoMove(){
  if (gameState.history.length>0){
    gameState = JSON.parse(JSON.stringify(gameState.history.pop()));
    render();
  }
}

function canPlaceOn(card, target){
  if (!target) return true;
  const ri = ranks.indexOf(card.rank);
  const rt = ranks.indexOf(target.rank);
  return (ri + 1 === rt) && (cardColor(card.suit) !== cardColor(target.suit));
}
function canPlaceOnFoundation(card, pile){
  if (pile.length === 0) return card.rank === "A";
  const top = pile[pile.length-1];
  const ri = ranks.indexOf(card.rank), rt = ranks.indexOf(top.rank);
  return (ri === rt + 1) && (card.suit === top.suit);
}
function validSequence(cards){
  for (let i=0;i<cards.length-1;i++){
    if (!canPlaceOn(cards[i+1], cards[i])) return false;
  }
  return true;
}

let draggedCards = [];
let sourceIdx = null;
let sourceType = null;

function dragStart(e){
  const id = e.currentTarget.dataset.id;
  for (let i=0;i<8;i++){
    const pile = gameState.tableau[i];
    const idx = pile.findIndex(c => cardId(c) === id);
    if (idx !== -1){
      const moving = pile.slice(idx);
      const maxAllowed = maxMovableCards();
      if (validSequence(moving) && moving.length <= maxAllowed){
        draggedCards = moving;
        sourceIdx = i;
        sourceType = "tableau";
        e.dataTransfer.setData('text/plain', id);
        e.dataTransfer.effectAllowed = 'move';
        return;
      } else {
        e.preventDefault();
        return;
      }
    }
  }
  for (let i=0;i<4;i++){
    const c = gameState.freecells[i];
    if (c && cardId(c) === id){
      draggedCards = [c];
      sourceIdx = i;
      sourceType = "freecell";
      e.dataTransfer.setData('text/plain', id);
      e.dataTransfer.effectAllowed = 'move';
      return;
    }
  }
}
function dragEnd(e){
  draggedCards = [];
  sourceIdx = null;
  sourceType = null;
}

function dropOnTableau(i){
  if (draggedCards.length === 0) return;
  const pile = gameState.tableau[i];
  const target = pile[pile.length - 1];
  const allowed = maxMovableCards(i);
  if (draggedCards.length > allowed) return;

  if ((pile.length === 0 && validSequence(draggedCards)) ||
      (pile.length > 0 && canPlaceOn(draggedCards[0], target) && validSequence(draggedCards))){
    saveState();
    if (sourceType === "tableau"){
      gameState.tableau[sourceIdx].splice(-draggedCards.length);
    } else if (sourceType === "freecell"){
      gameState.freecells[sourceIdx] = null;
    }
    gameState.tableau[i] = gameState.tableau[i].concat(draggedCards);
    draggedCards = [];
    render();
  }
}
function dropOnFreecell(i){
  if (draggedCards.length !== 1) return;
  if (!gameState.freecells[i]){
    saveState();
    if (sourceType === "tableau") gameState.tableau[sourceIdx].pop();
    else if (sourceType === "freecell") return;
    gameState.freecells[i] = draggedCards[0];
    draggedCards = [];
    render();
  }
}
function dropOnFoundation(i){
  if (draggedCards.length !== 1) return;
  const pile = gameState.foundations[i];
  if (canPlaceOnFoundation(draggedCards[0], pile)){
    saveState();
    if (sourceType === "tableau") gameState.tableau[sourceIdx].pop();
    else if (sourceType === "freecell") gameState.freecells[sourceIdx] = null;
    gameState.foundations[i].push(draggedCards[0]);
    draggedCards = [];
    render();
  }
}

function render(){
  const freeDiv = document.getElementById('freecells');
  const foundDiv = document.getElementById('foundations');
  const tabDiv = document.getElementById('tableau');
  freeDiv.innerHTML = ""; foundDiv.innerHTML = ""; tabDiv.innerHTML = "";

  for (let i=0;i<4;i++){
    const slot = document.createElement('div');
    slot.className = 'pile';
    slot.ondragover = e => e.preventDefault();
    slot.ondrop = () => dropOnFreecell(i);
    if (gameState.freecells[i]){
      slot.appendChild(createCardImg(gameState.freecells[i],0));
    }
    freeDiv.appendChild(slot);
  }

  for (let i=0;i<4;i++){
    const slot = document.createElement('div');
    slot.className = 'pile';
    slot.ondragover = e => e.preventDefault();
    slot.ondrop = () => dropOnFoundation(i);
    if (gameState.foundations[i].length > 0){
      slot.appendChild(createCardImg(gameState.foundations[i].slice(-1)[0],0));
    }
    foundDiv.appendChild(slot);
  }

  for (let i=0;i<8;i++){
    const slot = document.createElement('div');
    slot.className = 'pile';
    slot.ondragover = e => e.preventDefault();
    slot.ondrop = () => dropOnTableau(i);
    gameState.tableau[i].forEach((card, idx) => {
      slot.appendChild(createCardImg(card, idx));
    });
    tabDiv.appendChild(slot);
  }
}

// -------- HINT SYSTEM --------
function clearHints(){
  document.querySelectorAll('.hint-glow').forEach(el=>{
    el.classList.remove('hint-glow');
  });
}
function highlight(cardIdStr, type, idx){
  // الكارت
  const el = document.querySelector(`[data-id="${cardIdStr}"]`);
  if (el) el.classList.add("hint-glow");

  // المكان الهدف
  let targetEls;
  if (type==="tableau"){
    targetEls = document.querySelectorAll('#tableau .pile')[idx];
  } else if (type==="freecell"){
    targetEls = document.querySelectorAll('#freecells .pile')[idx];
  } else if (type==="foundation"){
    targetEls = document.querySelectorAll('#foundations .pile')[idx];
  }
  if (targetEls) targetEls.classList.add("hint-glow");
}

function showHint(){
  clearHints();
  // لف على كل الأعمدة
  for (let i=0;i<8;i++){
    const pile = gameState.tableau[i];
    if (pile.length === 0) continue;
    const card = pile[pile.length-1]; // آخر كارت

    // الأساسات
    for (let f=0;f<4;f++){
      if (canPlaceOnFoundation(card, gameState.foundations[f])){
        highlight(cardId(card), "foundation", f);
      }
    }
    // الفري سيل
    for (let f=0;f<4;f++){
      if (!gameState.freecells[f]){
        highlight(cardId(card), "freecell", f);
      }
    }
    // التابلـو
    for (let j=0;j<8;j++){
      if (i===j) continue;
      const target = gameState.tableau[j][gameState.tableau[j].length-1];
      if ((target && canPlaceOn(card,target)) || (!target)){
        highlight(cardId(card), "tableau", j);
      }
    }
  }
}

restartGame();
</script>
</body>
</html>
