<!DOCTYPE html>
<html lang="ar">
<head>
  <meta charset="UTF-8">
  <title>FreeCell - Ù†Ø³Ø®Ø© ÙˆÙŠØ¨</title>
  <style>
    body { background:#064420; color:white; font-family:Arial; margin:0; }
    h1 { text-align:center; margin:10px; }
    #controls { text-align:center; margin:10px; }
    button {
      margin:5px; padding:8px 15px; border:none; border-radius:5px;
      background:#1b4332; color:white; cursor:pointer;
    }
    button:hover{ background:#2d6a4f; }
    #game { display:flex; flex-direction:column; align-items:center; }
    #top-row,#bottom-row { display:flex; justify-content:center; margin:10px; }
    .pile {
      width:80px; height:120px;
      border:1px dashed rgba(255,255,255,0.4);
      border-radius:8px; margin:5px; position:relative;
      background: rgba(255,255,255,0.02);
    }
    .card {
      width:80px; height:120px; border-radius:8px;
      position:absolute; cursor:grab; user-select:none;
    }
    .hint-outline{ outline: 3px solid gold; }
  </style>
</head>
<body>
  <h1>Ù„Ø¹Ø¨Ø© FreeCell</h1>
  <div id="controls">
    <button onclick="restartGame()">Ø¥Ø¹Ø§Ø¯Ø© ØªØ´ØºÙŠÙ„</button>
    <button onclick="undoMove()">ØªØ±Ø§Ø¬Ø¹ (Undo)</button>
    <button onclick="showHint()">ØªÙ„Ù…ÙŠØ­ (Hint)</button>
  </div>
  <div id="game">
    <div id="top-row">
      <div id="freecells" style="display:flex;"></div>
      <div id="foundations" style="display:flex; margin-left:50px;"></div>
    </div>
    <div id="bottom-row">
      <div id="tableau" style="display:flex;"></div>
    </div>
  </div>

<script>
const ranks=["A","2","3","4","5","6","7","8","9","10","J","Q","K"];
const suits=["S","H","D","C"];
let gameState={tableau:[],freecells:[],foundations:[],history:[]};

function cardId(c){return c.rank+c.suit;}
function cardColor(s){return (s==="H"||s==="D")?"red":"black";}

function createCardImg(card,idx=0,draggable=true){
  const img=document.createElement('img');
  img.className='card';
  img.src=`Cards/${card.rank}${card.suit}.jpg`;
  img.dataset.id=cardId(card);
  img.style.top=(idx*25)+"px";
  img.draggable=draggable;
  img.ondragstart=dragStart;
  return img;
}

function initDeck(){
  let d=[]; for (let r of ranks){ for (let s of suits){ d.push({rank:r,suit:s}); } }
  for (let i=d.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [d[i],d[j]]=[d[j],d[i]]; }
  return d;
}

function restartGame(){
  const deck=initDeck();
  gameState.tableau=[[],[],[],[],[],[],[],[]];
  for (let i=0;i<deck.length;i++){ gameState.tableau[i%8].push(deck[i]); }
  gameState.freecells=[null,null,null,null];
  gameState.foundations=[[],[],[],[]];
  gameState.history=[];
  render();
}

function saveState(){ gameState.history.push(JSON.parse(JSON.stringify(gameState))); }
function undoMove(){ if (gameState.history.length>0){ gameState=gameState.history.pop(); render(); } }

function canPlaceOn(card,target){
  if (!target) return true;
  const ri=ranks.indexOf(card.rank), rt=ranks.indexOf(target.rank);
  return (ri===rt-1 && cardColor(card.suit)!==cardColor(target.suit));
}
function canPlaceOnFoundation(card,pile){
  if (pile.length===0) return card.rank==="A";
  const top=pile[pile.length-1];
  const ri=ranks.indexOf(card.rank), rt=ranks.indexOf(top.rank);
  return (ri===rt+1 && card.suit===top.suit);
}

// ===== Stack move support =====
function countEmptyFreecells(){ return gameState.freecells.filter(f=>!f).length; }
function countEmptyTableaus(){ return gameState.tableau.filter(p=>p.length===0).length; }
function maxMovableCards(){ return (countEmptyFreecells()+1)*Math.pow(2,countEmptyTableaus()); }

function validSequence(cards){
  // cards[0] is the lower card (closer to the bottom of the moved stack)
  // for a valid sequence we need: card[i] rank == card[i+1].rank + 1 and opposite color
  for (let i=0;i<cards.length-1;i++){
    const lower = cards[i];
    const upper = cards[i+1];
    const rLower = ranks.indexOf(lower.rank);
    const rUpper = ranks.indexOf(upper.rank);
    if (rLower !== rUpper + 1) return false; // not descending by 1
    if (cardColor(lower.suit) === cardColor(upper.suit)) return false; // same color -> invalid
  }
  return true;
}

// Drag & Drop
let draggedCards=[], sourceIdx=null, sourceType=null;
function dragStart(e){
  const id=e.target.dataset.id;
  // try tableau (allow stack moves)
  for (let i=0;i<8;i++){
    const pile=gameState.tableau[i];
    const idx=pile.findIndex(c=>cardId(c)===id);
    if (idx!==-1){
      const moving=pile.slice(idx);
      if (moving.length<=maxMovableCards() && validSequence(moving)){
        draggedCards = moving.slice(); // copy
        sourceIdx = i; sourceType = "tableau";
        return;
      } else { draggedCards=[]; return; }
    }
  }
  // try freecells
  for (let i=0;i<4;i++){
    const c = gameState.freecells[i];
    if (c && cardId(c)===id){ draggedCards=[c]; sourceIdx=i; sourceType="freecell"; return; }
  }
}

function dropOnTableau(i){
  if (draggedCards.length===0) return;
  const pile=gameState.tableau[i];
  const target = pile[pile.length-1];
  if (pile.length===0 || canPlaceOn(draggedCards[0], target)){
    saveState();
    if (sourceType==="tableau"){
      const srcPile = gameState.tableau[sourceIdx];
      const removeStart = srcPile.length - draggedCards.length;
      srcPile.splice(removeStart, draggedCards.length);
    } else if (sourceType==="freecell"){
      gameState.freecells[sourceIdx] = null;
    }
    gameState.tableau[i] = gameState.tableau[i].concat(draggedCards);
    draggedCards = [];
    render();
  }
}

function dropOnFreecell(i){
  if (draggedCards.length!==1) return;
  if (!gameState.freecells[i]){
    saveState();
    if (sourceType==="tableau") gameState.tableau[sourceIdx].pop();
    else if (sourceType==="freecell") return;
    gameState.freecells[i] = draggedCards[0];
    draggedCards = [];
    render();
  }
}

function dropOnFoundation(i){
  if (draggedCards.length!==1) return;
  const pile = gameState.foundations[i];
  if (canPlaceOnFoundation(draggedCards[0], pile)){
    saveState();
    if (sourceType==="tableau") gameState.tableau[sourceIdx].pop();
    else if (sourceType==="freecell") gameState.freecells[sourceIdx] = null;
    pile.push(draggedCards[0]);
    draggedCards = [];
    render();
  }
}

// âœ… ÙØ­Øµ Ø§Ù„ÙÙˆØ²
function checkWin(){
  const total = gameState.foundations.reduce((a,p)=>a+p.length,0);
  if (total===52){ setTimeout(()=>alert("ğŸ‰ Ù…Ø¨Ø±ÙˆÙƒØŒ ÙØ²Øª!"),100); }
}

// Rendering
function render(){
  const freeDiv=document.getElementById('freecells');
  const foundDiv=document.getElementById('foundations');
  const tabDiv=document.getElementById('tableau');
  freeDiv.innerHTML=''; foundDiv.innerHTML=''; tabDiv.innerHTML='';

  for (let i=0;i<4;i++){
    const slot=document.createElement('div');
    slot.className='pile'; slot.ondragover = e=>e.preventDefault(); slot.ondrop = ()=>dropOnFreecell(i);
    if (gameState.freecells[i]) slot.appendChild(createCardImg(gameState.freecells[i]));
    freeDiv.appendChild(slot);
  }

  for (let i=0;i<4;i++){
    const slot=document.createElement('div');
    slot.className='pile'; slot.ondragover = e=>e.preventDefault(); slot.ondrop = ()=>dropOnFoundation(i);
    if (gameState.foundations[i].length>0){ const top=gameState.foundations[i][gameState.foundations[i].length-1]; slot.appendChild(createCardImg(top)); }
    foundDiv.appendChild(slot);
  }

  for (let i=0;i<8;i++){
    const slot=document.createElement('div');
    slot.className='pile'; slot.ondragover = e=>e.preventDefault(); slot.ondrop = ()=>dropOnTableau(i);
    gameState.tableau[i].forEach((card,idx)=>{ slot.appendChild(createCardImg(card,idx)); });
    tabDiv.appendChild(slot);
  }

  checkWin();
}

// Hint (simple)
function showHint(){
  // try any single-card foundation move
  for (let i=0;i<8;i++){
    const p=gameState.tableau[i]; if (!p.length) continue;
    const c=p[p.length-1];
    for (let j=0;j<4;j++){ if (canPlaceOnFoundation(c, gameState.foundations[j])){ alert('ÙŠÙ…ÙƒÙ† Ù†Ù‚Ù„ '+cardId(c)+' Ø¥Ù„Ù‰ Foundation '+(j+1)); return; } }
  }
  // try single-card to freecell
  for (let i=0;i<8;i++){ const p=gameState.tableau[i]; if (!p.length) continue; const c=p[p.length-1]; const freeIdx=gameState.freecells.findIndex(f=>!f); if (freeIdx!==-1){ alert('ÙŠÙ…ÙƒÙ† Ù†Ù‚Ù„ '+cardId(c)+' Ø¥Ù„Ù‰ Freecell '+(freeIdx+1)); return; } }
  alert('Ù„Ø§ ØªÙˆØ¬Ø¯ ØªÙ„Ù…ÙŠØ­Ø§Øª Ù…ØªØ§Ø­Ø©');
}

restartGame();
</script>
</body>
</html>
