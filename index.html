<!DOCTYPE html>
<html lang="ar">
<head>
  <meta charset="UTF-8">
  <title>FreeCell - ŸàŸäÿ®</title>
  <style>
    body { background:#064420; color:white; font-family:Arial; margin:0; }
    h1 { text-align:center; margin:10px; }
    #controls { text-align:center; margin:10px; }
    button {
      margin:5px; padding:8px 15px; border:none; border-radius:5px;
      background:#1b4332; color:white; cursor:pointer;
    }
    button:hover{ background:#2d6a4f; }
    #game { display:flex; flex-direction:column; align-items:center; }
    #top-row {
      display: flex;
      justify-content: space-between;
      width: 800px;
      margin: 10px;
    }
    #freecells {
      display: flex;
      gap: 8px;
    }
    #foundations {
      display: flex;
      gap: 8px;
    }
    #bottom-row {
      display:flex;
      justify-content:center;
      margin:10px;
      width: 100vw;
    }
    #tableau {
      display: flex;
      justify-content: center;
      width: 100vw;
      gap: 8px;
    }
    .pile {
      width:80px; height:120px;
      border:1px dashed rgba(255,255,255,0.4);
      border-radius:8px; margin:5px; position:relative;
      background:rgba(255,255,255,0.01);
      transition: border-color 0.18s;
    }
    .pile.hint {
      border-color: #ffd700 !important;
      box-shadow: 0 0 10px 2px #ffd70055;
      animation: shake 0.18s 2;
    }
    @keyframes shake {
      0% { transform: translateX(0);}
      25% { transform: translateX(-6px);}
      50% { transform: translateX(6px);}
      75% { transform: translateX(-3px);}
      100% { transform: translateX(0);}
    }
    .card {
      width:80px; height:120px; border-radius:8px;
      position:absolute; cursor:grab;
      box-shadow: 0 2px 6px #0005;
      user-select: none;
      border:2px solid #0002;
      transition: box-shadow 0.15s, border-color 0.12s;
    }
    .card.hint {
      box-shadow: 0 0 18px 4px #ffd700aa;
      border-color: #ffd700;
      animation: shake 0.18s 2;
    }
  </style>
</head>
<body>
  <h1>FreeCell</h1>
  <div id="controls">
    <button onclick="restartGame()">ÿ•ÿπÿßÿØÿ© ÿ™ÿ¥ÿ∫ŸäŸÑ</button>
    <button onclick="undoMove()">ÿ™ÿ±ÿßÿ¨ÿπ</button>
    <button onclick="showHint()">ÿ™ŸÑŸÖŸäÿ≠</button>
  </div>
  <div id="game">
    <div id="top-row">
      <div id="freecells"></div>
      <div id="foundations"></div>
    </div>
    <div id="bottom-row">
      <div id="tableau"></div>
    </div>
  </div>

<script>
const ranks=["A","2","3","4","5","6","7","8","9","10","J","Q","K"];
const suits=["S","H","D","C"];

let gameState = {
  tableau:[[],[],[],[],[],[],[],[]],
  freecells:[null,null,null,null],
  foundations:[[],[],[],[]],
  history:[]
};

function cardId(c){ return c.rank+c.suit; }
function cardColor(s){ return (s==="H"||s==="D")?"red":"black"; }

function createCardImg(card,idx=0){
  const img=document.createElement('img');
  img.className='card';
  img.src=`Cards/${card.rank}${card.suit}.jpg`;
  img.dataset.id=cardId(card);
  img.style.top=(idx*25)+"px";
  img.draggable=true;
  img.ondragstart=dragStart;
  return img;
}

// ====== Game Init ======
function initDeck(){
  let d=[]; 
  for (let r of ranks){ for (let s of suits){ d.push({rank:r,suit:s}); } }
  for (let i=d.length-1;i>0;i--){ 
    const j=Math.floor(Math.random()*(i+1)); 
    [d[i],d[j]]=[d[j],d[i]]; 
  }
  return d;
}

function restartGame(){
  const deck=initDeck();
  gameState.tableau=[[],[],[],[],[],[],[],[]];
  for (let i=0;i<deck.length;i++){ gameState.tableau[i%8].push(deck[i]); }
  gameState.freecells=[null,null,null,null];
  gameState.foundations=[[],[],[],[]];
  gameState.history=[];
  render();
}

function saveState(){ 
  gameState.history.push(JSON.parse(JSON.stringify(gameState))); 
}
function undoMove(){
  if (gameState.history.length>0){
    const prev = gameState.history.pop();
    gameState = JSON.parse(JSON.stringify(prev));
    render();
  }
}

// ====== Rules ======
function canPlaceOn(card, target) {
  if (!target) return true;
  const ri = ranks.indexOf(card.rank), rt = ranks.indexOf(target.rank);
  return (ri === rt + 1 && cardColor(card.suit) !== cardColor(target.suit));
}
function canPlaceOnFoundation(card,pile){
  if (pile.length===0) return card.rank==="A";
  const top=pile[pile.length-1];
  const ri=ranks.indexOf(card.rank), rt=ranks.indexOf(top.rank);
  return (ri===rt+1 && card.suit===top.suit);
}

function validSequence(cards){
  for (let i=0;i<cards.length-1;i++){
    if (!canPlaceOn(cards[i+1], cards[i])) return false;
  }
  return true;
}

function countEmptyFreecells(){ return gameState.freecells.filter(f=>!f).length; }
function countEmptyTableaus(){ return gameState.tableau.filter(p=>p.length===0).length; }
function maxMovableCards(){ return (countEmptyFreecells()+1)*Math.pow(2,countEmptyTableaus()); }

// ====== Drag & Drop ======
let draggedCards=[],sourceIdx=null,sourceType=null;
function dragStart(e){
  const id=e.target.dataset.id;
  // tableau
  for (let i=0;i<8;i++){
    const pile=gameState.tableau[i];
    const idx=pile.findIndex(c=>cardId(c)===id);
    if (idx!==-1){
      const moving=pile.slice(idx);
      if (moving.length<=maxMovableCards() && validSequence(moving)){
        draggedCards=moving; sourceIdx=i; sourceType="tableau"; return;
      } else { draggedCards=[]; return; }
    }
  }
  // freecell
  for (let i=0;i<4;i++){
    const c=gameState.freecells[i];
    if (c && cardId(c)===id){ draggedCards=[c]; sourceIdx=i; sourceType="freecell"; return; }
  }
}

function dropOnTableau(i){
  if (draggedCards.length===0) return;
  const pile=gameState.tableau[i];
  const target=pile[pile.length-1];
  if ((pile.length===0 && validSequence(draggedCards)) ||
      (pile.length>0 && canPlaceOn(draggedCards[0],target) && validSequence(draggedCards))) {
    saveState();
    if (sourceType==="tableau"){ gameState.tableau[sourceIdx].splice(-draggedCards.length); }
    else if (sourceType==="freecell"){ gameState.freecells[sourceIdx]=null; }
    gameState.tableau[i]=gameState.tableau[i].concat(draggedCards);
    draggedCards=[]; 
    render();
    checkWin();
  }
}

function dropOnFreecell(i){
  if (draggedCards.length!==1) return;
  if (!gameState.freecells[i]){
    saveState();
    if (sourceType==="tableau"){ gameState.tableau[sourceIdx].pop(); }
    else if (sourceType==="freecell") return;
    gameState.freecells[i]=draggedCards[0];
    draggedCards=[]; 
    render();
    checkWin();
  }
}

function dropOnFoundation(i){
  if (draggedCards.length!==1) return;
  const pile=gameState.foundations[i];
  if (canPlaceOnFoundation(draggedCards[0],pile)){
    saveState();
    if (sourceType==="tableau"){ gameState.tableau[sourceIdx].pop(); }
    else if (sourceType==="freecell"){ gameState.freecells[sourceIdx]=null; }
    gameState.foundations[i].push(draggedCards[0]);
    draggedCards=[]; 
    render();
    checkWin();
  }
}

// ====== Hint ======
let lastHint = null;
function showHint(){
  clearHints();
  // ÿ£ŸàŸÑÿßŸã: ÿ¨ÿ±ÿ® ŸÜŸÇŸÑ ŸÖŸÜ tableau ÿ•ŸÑŸâ foundation
  for (let i=0;i<8;i++){
    const pile=gameState.tableau[i];
    if (pile.length>0){
      const c=pile[pile.length-1];
      for (let j=0;j<4;j++){
        if (canPlaceOnFoundation(c,gameState.foundations[j])){
          highlightCard(c);
          highlightPile('foundations',j);
          lastHint = {type: "foundation", from: i, to: j, card: c};
          return;
        }
      }
    }
  }
  // ÿ´ÿßŸÜŸäÿßŸã: ÿ¨ÿ±ÿ® ŸÜŸÇŸÑ ŸÖŸÜ tableau ÿ•ŸÑŸâ tableau ÿ£ÿÆÿ±Ÿâ
  for (let i=0;i<8;i++){
    const pile=gameState.tableau[i];
    if (pile.length>0){
      for (let j=0;j<8;j++){
        if (i===j) continue;
        const c = pile[pile.length-1];
        const target = gameState.tableau[j][gameState.tableau[j].length-1];
        if ((gameState.tableau[j].length===0 && validSequence([c])) ||
            (gameState.tableau[j].length>0 && canPlaceOn(c,target) && validSequence([c]))) {
          highlightCard(c);
          highlightPile('tableau',j);
          lastHint = {type: "tableau", from: i, to: j, card: c};
          return;
        }
      }
    }
  }
  // ÿ´ÿßŸÑÿ´ÿßŸã: ÿ¨ÿ±ÿ® ŸÜŸÇŸÑ ŸÖŸÜ tableau ÿ•ŸÑŸâ freecell
  for (let i=0;i<8;i++){
    const pile=gameState.tableau[i];
    if (pile.length>0){
      for (let j=0;j<4;j++){
        if (!gameState.freecells[j]){
          highlightCard(pile[pile.length-1]);
          highlightPile('freecells',j);
          lastHint = {type: "freecell", from: i, to: j, card: pile[pile.length-1]};
          return;
        }
      }
    }
  }
  // ÿ±ÿßÿ®ÿπÿßŸã: ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ™ŸÑŸÖŸäÿ≠ÿßÿ™
  lastHint = null;
}

function clearHints() {
  document.querySelectorAll('.card.hint').forEach(card => card.classList.remove('hint'));
  document.querySelectorAll('.pile.hint').forEach(pile => pile.classList.remove('hint'));
}
function highlightCard(card){
  setTimeout(() => {
    document.querySelectorAll('.card').forEach(img=>{
      if(img.dataset.id===cardId(card)) img.classList.add('hint');
    });
  },5);
}
function highlightPile(type,idx){
  setTimeout(() => {
    let sel = '';
    if(type==="freecells") sel = "#freecells>.pile";
    else if(type==="foundations") sel = "#foundations>.pile";
    else sel = "#tableau>.pile";
    document.querySelectorAll(sel)[idx].classList.add('hint');
  },5);
}

// ====== Check Win ======
function checkWin(){
  let total = 0;
  for(let i=0;i<4;i++) total += gameState.foundations[i].length;
  if(total === 52){
    setTimeout(()=>{ alert("ŸÖÿ®ÿ±ŸàŸÉ! ŸÑŸÇÿØ ŸÅÿ≤ÿ™ ÿ®ÿßŸÑŸÑÿπÿ®ÿ© üéâ"); }, 100);
  }
}

// ====== Render ======
function render(){
  clearHints();
  const freeDiv=document.getElementById('freecells');
  const foundDiv=document.getElementById('foundations');
  const tabDiv=document.getElementById('tableau');
  freeDiv.innerHTML=""; foundDiv.innerHTML=""; tabDiv.innerHTML="";
  
  // freecells
  for (let i=0;i<4;i++){
    const slot=document.createElement('div');
    slot.className='pile';
    slot.ondragover=e=>e.preventDefault();
    slot.ondrop=()=>dropOnFreecell(i);
    if (gameState.freecells[i]) slot.appendChild(createCardImg(gameState.freecells[i]));
    freeDiv.appendChild(slot);
  }
  // foundations
  for (let i=0;i<4;i++){
    const slot=document.createElement('div');
    slot.className='pile';
    slot.ondragover=e=>e.preventDefault();
    slot.ondrop=()=>dropOnFoundation(i);
    if (gameState.foundations[i].length>0){
      const top=gameState.foundations[i][gameState.foundations[i].length-1];
      slot.appendChild(createCardImg(top));
    }
    foundDiv.appendChild(slot);
  }
  // tableau
  for (let i=0;i<8;i++){
    const slot=document.createElement('div');
    slot.className='pile';
    slot.ondragover=e=>e.preventDefault();
    slot.ondrop=()=>dropOnTableau(i);
    gameState.tableau[i].forEach((card,idx)=>{
      slot.appendChild(createCardImg(card,idx));
    });
    tabDiv.appendChild(slot);
  }
}

restartGame();
</script>
</body>
</html>
